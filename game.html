<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Bricks Breaker!</title>
    <script src="config.js" charset="utf-8"></script>
    <script src="levels.js" charset="utf-8"></script>
    <script src="utils.js" charset="utf-8"></script>
    <script src="game.js" charset="utf-8"></script>
    <script src="paddle.js" charset="utf-8"></script>
    <script src="ball.js" charset="utf-8"></script>
    <script src="brick.js" charset="utf-8"></script>
</head>
<body>
    <canvas id="id-canvas" width="480" height="270" style="border: 2px solid  green"></canvas>

    <script>
    var loadLevel = function(level) {
        var bricks = []
        // 正常选关从1开始
        // 但是数组的数据是从零开始
        var data = levels[level - 1]
        for (var i = 0; i < data.length; i++) {
            // 分别代表传入一个砖块的x值和y值
            bricks.push(Brick(data[i][0], data[i][1]))
        }
        return bricks
    }

        var __main = function() {
            // 开始创建变量和设置游戏
            var game = Game()
            var paddle = Paddle()
            var ball = Ball()
            var bricks = loadLevel(1)

            game.registerAction('a', function() {
                paddle.moveLeft()
            })

            game.registerAction('d', function() {
                paddle.moveRight()
            })

            game.registerAction('w', function() {
                paddle.moveUp()
            })

            game.registerAction('s', function() {
                paddle.moveDown()
            })

            game.registerAction(' ', function() {
                ball.move()
            })

            window.addEventListener('keydown', function(event) {
                if (event.key == '1') {
                    bricks = loadLevel(1)
                }
                else if (event.key == '2') {
                    bricks = loadLevel(2)
                }
            })

            // 这里不用考虑图片载入的问题
            // 没载入，同样画出来，对画布没影响
            // 已经在入了，那就可以画了，就可以看到
            // game.draw = function() {
            //     game.context.clearRect(0, 0, game.canvas.width, game.canvas.height)
            //     game.context.drawImage(paddle.image, paddle.x, paddle.y)
            // }

            // 判断球和板子是不是相碰了
            game.collide = function() {
                // 上下相碰，先不考虑左右两边,只改变球的Y方向的速度speedY
                // 球严格在挡板两端的长度以内
                if ((ball.x + ball.image.width > paddle.x && ball.x < paddle.x + paddle.image.width)
                 && (ball.y + ball.image.height > paddle.y && ball.y < paddle.y + paddle.image.height)) {
                    ball.speedY *= -1
                }

                // 球和砖块碰撞没有
                for (var i = 0; i < bricks.length; i++) {
                    var b = bricks[i]
                    b.collide(ball)
                }
            }

            // 定义draw的含义，在setInterval里面会不停地调用这个重新定义过的函数
            game.draw = function() {
                game.drawImage(paddle)
                game.drawImage(ball)
                for (var i = 0; i < bricks.length; i++) {
                    var b = bricks[i]
                    if (b.alive) {
                        game.drawImage(b)
                    }
                }
            }
        }

        __main()
    </script>
</body>
</html>
